1.
Verilog определяет некоторые базовые логические вентили как часть языка,
например, следующие гейты: and, or, xor, not, nand, nor, xnor.

Выходные порты этих элементов указываются в начале списка, все остальные
в конце.

Гейты and, nand, or, nor, xor, xnor поддерживают больше 2 входных параметров:

nand nand1(out, in1, in2, in3, in4, in5);

Логическаим вентилям можно указывать временные задержки, но так как мы
программисты, а не схемотехники, мы этого делать не будем.

Чтобы собрать пример делаем так:

iverilog -o mynand mynand.v mynand_test.v
vvp mynand

2.
Пользоваться такими логическими вентилями жутко неудобно, поэтому вместо них
можно просто пользоваться логическими/битовыми операциями и оператором assign:

module mynand(c, a, b);
    input a, b;
    output c;
    assign c = !(a && b); // nand
endmodule

assign - также называется непрерывным присваиванием, т. е. этим оператором мы
как бы соединяем провода, и как бы не менялись входы, это отражается на выходах.
Как и гейтам присваиванию можно назначать задержки.

3.
Мы постоянно используем модули, но я еще не рассказывал о них. Модули - это
структурная единица языка Verilog. Каждый модуль должен распологаться в файле
с тем же именем. Из всех модулей один является top level и он может выбираться
автоматически, а так же его можно указать явно флагом -s.

iverilog -s mynand2_test -o mynand2 mynand2.v mynand2_test.v
vvp mynand2

